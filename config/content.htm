<h1>About</h1>
<p>40823146蕭宏翔</p>
<p>倉儲:<a href="https://github.com/40823146/cd2021">https://github.com/40823146/cd2021</a></p>
<p>網頁:<a href="https://40823146.github.io/cd2021/content/index.html">https://40823146.github.io/cd2021/content/index.html</a></p>
<p></p>
<h1>W2~W4</h1>
<p>兩人一組</p>
<p>stage1-ag16</p>
<p>題目:電風扇</p>
<p>動機:因應季節改變</p>
<p>W2~W3:零件繪製以及放到coppeliasim上模擬並改錯</p>
<p>W4:報告</p>
<p>我負責的部分是Coppeliasim的處理以及小組倉儲的更新</p>
<p>在Coppeliasim上模擬的在Coppeliasim上模擬的電風扇</p>
<p>影片:<a href="https://www.youtube.com/watch?v=Kjx-otNs8v0">https://www.youtube.com/watch?v=Kjx-otNs8v0</a></p>
<p><img alt="" height="426" src="/images/12 1n.png" width="855"/></p>
<h1>W5~W9</h1>
<p>四人一組</p>
<p>stage2-ag9</p>
<p>題目:旋轉木馬音樂盒</p>
<p>w5:討論</p>
<p>w6~8:零件繪製以及coppeliasim模擬</p>
<p>w9:報告</p>
<p>我負責coppeliasim的模擬以及下半部的齒輪組裝及繪製</p>
<p>在solidwork上利用以下關係式所繪製出的</p>
<p><img alt="" height="414" src="/images/math.jpg" width="325"/></p>
<p><img alt="" height="445" src="/images/齒輪箱.jpg" width="818"/></p>
<p>在coppeliasim上的模擬</p>
<p><img alt="" height="454" src="/images/cop.jpg" width="804"/></p>
<p><a href="https://www.youtube.com/watch?v=jTRXSWgXC44">https://www.youtube.com/watch?v=jTRXSWgXC44</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/jTRXSWgXC44" width="560"></iframe></p>
<p>這次模擬時上面未加限制導致木馬轉到一半時掉下來</p>
<p><a href="https://youtu.be/7TRqhprKHqk">https://youtu.be/7TRqhprKHqk<iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/7TRqhprKHqk" width="560"></iframe></a></p>
<h1>w11~w18</h1>
<h2>stage3-ag4</h2>
<p>以下為更改八隻腳的設定影片</p>
<p>但部分尚未處理完成</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ncac9No6wkI" width="560"></iframe></p>
<h2>w11</h2>
<p>被抽到直播教學</p>
<p>以下是ssh的設定教學以及我的紀錄檔</p>
<p><a href="https://www.youtube.com/watch?v=gvuEAUnpd3k" rel="nofollow">https://www.youtube.com/watch?v=gvuEAUnpd3k</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/gvuEAUnpd3k" width="560"></iframe></p>
<h2>w12</h2>
<p>w12也被抽到直播教學</p>
<p>以下是task2的教學影片 因為使用手機網路的關係導致影片還沒儲存完全</p>
<p><a href="https://www.youtube.com/watch?v=nXythOvdul0" rel="nofollow">https://www.youtube.com/watch?v=nXythOvdul0</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/nXythOvdul0" width="560"></iframe></p>
<h2>w13~w14</h2>
<h3>小組會議</h3>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/fVl2O2MoRlQ" width="560"></iframe></p>
<h3>task1</h3>
<p>參考40823131的task1</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># open file, default is read mode, since txt content no chinese char4
# no encoding = "UTF-08" is needed
with open("stage3_2a.txt") as fh: #打開"stage3_2a.txt檔案並命名為fh
    # readlines will read into the whole line and put into list format 23
    # has \n at the end of each line 13
    #讀取 fh檔案並當作data
    data = fh.readlines()
    #修改錯誤的學號
    data = [a.replace('4823122','40823122') for a in data]
    #去除組別空白部分
    data = [b.replace('\t\t\t\t','') for b in data]
 
    #print(data)#印出data
#print(len(data))
for i in range(len(data)):#設i迴圈的次數為data的長度
    #print(data)
    group = data[i].rstrip("\n").split("\t")#設group為取data的次數i消除\n並且以\t分割數列
 
    #print(group)
    print('&lt;p&gt;'+group[0]+' ＿ &lt;a href="https://'+group[1]+'.github.io/'+group[0]+'"&gt;site&lt;/a&gt; | &lt;a href="https://github.com/'+group[1]+'/'+group[0]+'"&gt;repo&lt;/a&gt;&lt;/p&gt;')
#印出group字串
  
   
    for g in range(2,18,2):#設g迴圈的範圍從第3項開始+2到第18項
        try:#try...except 可跳過讀取不到的資料
            print('&lt;p&gt;'+group[g]+'＿site:'+'&lt;a href="https://'+group[g]+'.github.io/cd2021'+'"&gt;'+group[g]+'&lt;/a&gt;'+'|repo:'+'&lt;a href="https://github.com/'+group[g]+'/cd2021'+'"&gt;'+group[g]+'&lt;/a&gt;&lt;/p&gt;')
            #印出group字串
    
        except:
            continue#返回迴圈</pre>
<h3>task2</h3>
<p>這邊用stage1的題目</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/qgWIu7iAfTs" width="560"></iframe></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sim as vrep
import sys
# child threaded script: 
#simExtRemoteApiStart(19999)
 
vrep.simxFinish(-1)
 
clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5)
 
if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')
 
errorCode,main_handle=vrep.simxGetObjectHandle(clientID,'main',vrep.simx_opmode_oneshot_wait)
 

 
if errorCode == -1:
    print('Can not find main_handle')
    sys.exit()
 
errorCode=vrep.simxSetJointTargetVelocity(clientID,main_handle,20, vrep.simx_opmode_oneshot_wait)
</pre>
<h3>robodk</h3>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/9n9a6cyIbJc" width="560"></iframe></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># KMOLab Portable RoboDK pick and place
from robolink import *    # API to communicate with robodk
from robodk import *      # robodk robotics toolbox
 
# Setup global parameters
BALL_DIAMETER = 100 # diameter of one ball
APPROACH = 100      # approach distance to grab each part, in mm
nTCPs = 6           # number of TCP's in the tool
 
#----------------------------------------------
# Function definitions
 
def box_calc(BALLS_SIDE=4, BALLS_MAX=None):
    """Calculate a list of points (ball center) as if the balls were stored in a box"""
    if BALLS_MAX is None: BALLS_MAX = BALLS_SIDE**3
    xyz_list = []
    for h in range(BALLS_SIDE):
        for i in range(BALLS_SIDE):
            for j in range(BALLS_SIDE):
                xyz_list = xyz_list + [[(i+0.5)*BALL_DIAMETER, (j+0.5)*BALL_DIAMETER, (h+0.5)*BALL_DIAMETER]]
                if len(xyz_list) &gt;= BALLS_MAX:
                    return xyz_list
    return xyz_list
 
def pyramid_calc(BALLS_SIDE=4):
    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""
    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)
    BALL_DIAMETER = 100
    xyz_list = []
    sqrt2 = 2**(0.5)
    for h in range(BALLS_SIDE):
        for i in range(BALLS_SIDE-h):
            for j in range(BALLS_SIDE-h):
                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2
                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]
    return xyz_list
 
def balls_setup(frame, positions):
    """Place a list of balls in a reference frame. The reference object (ball) must have been previously copied to the clipboard."""
    nballs = len(positions)
    step = 1.0/(nballs - 1)
    for i in range(nballs):
        newball = frame.Paste()
        newball.setName('ball ' + str(i)) #set item name
        newball.setPose(transl(positions[i])) #set item position with respect to parent
        newball.setVisible(True, False) #make item visible but hide the reference frame
        newball.Recolor([1-step*i, step*i, 0.2, 1]) #set RGBA color
 
def cleanup_balls(parentnodes):
    """Delete all child items whose name starts with \"ball\", from the provided list of parent items."""
    todelete = []
    for item in parentnodes:
        todelete = todelete + item.Childs()
 
    for item in todelete:
        if item.Name().startswith('ball'):
            item.Delete()
 
def TCP_On(toolitem, tcp_id):
    """Attach the closest object to the toolitem Htool pose,
    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""
    toolitem.AttachClosest()
    toolitem.RDK().RunMessage('Set air valve %i on' % (tcp_id+1))
    toolitem.RDK().RunProgram('TCP_On(%i)' % (tcp_id+1));
         
def TCP_Off(toolitem, tcp_id, itemleave=0):
    """Detaches the closest object attached to the toolitem Htool pose,
    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""
    toolitem.DetachAll(itemleave)
    toolitem.RDK().RunMessage('Set air valve %i off' % (tcp_id+1))
    toolitem.RDK().RunProgram('TCP_Off(%i)' % (tcp_id+1));
 
 
#----------------------------------------------------------
# The program starts here:
 
# Any interaction with RoboDK must be done through RDK:
RDK = Robolink(robodk_path="C:/robodk/bin/RoboDK.exe", robodk_ip='127.0.0.1')
 
# Turn off automatic rendering (faster)
RDK.Render(False)
 
#RDK.Set_Simulation_Speed(500); # set the simulation speed
 
# Gather required items from the station tree
robot = RDK.Item('Fanuc M-710iC/50')
robot_tools = robot.Childs()
#robottool = RDK.Item('MainTool')
frame1 = RDK.Item('Table 1')
frame2 = RDK.Item('Table 2')
 
# Copy a ball as an object (same as CTRL+C)
ballref = RDK.Item('reference ball')
ballref.Copy()
 
# Run a pre-defined station program (in RoboDK) to replace the two tables
prog_reset = RDK.Item('Replace objects')
prog_reset.RunProgram()
 
# Call custom procedure to remove old objects
cleanup_balls([frame1, frame2])
 
# Make a list of positions to place the objects
frame1_list = pyramid_calc(4)
frame2_list = pyramid_calc(4)
 
# Programmatically place the objects with a custom-made procedure
balls_setup(frame1, frame1_list)
 
# Delete previously generated tools
for tool in robot_tools:
    if tool.Name().startswith('TCP'):
        tool.Delete()
         
# Calculate tool frames for the suction cup tool of 6 suction cups
TCP_list = []
for i in range(nTCPs):
    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)
    TCPi = robot.AddTool(TCPi_pose, 'TCP %i' % (i+1))
    TCP_list.append(TCPi)
 
TCP_0 = TCP_list[0]
 
# Turn on automatic rendering
RDK.Render(True)
 
# Move balls    
robot.setPoseTool(TCP_list[0])
nballs_frame1 = len(frame1_list)
nballs_frame2 = len(frame2_list)
idTake = nballs_frame1 - 1
idLeave = 0
idTCP = 0
target_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)
 
while idTake &gt;= 0:
    # ------------------------------------------------------------------
    # first priority: grab as many balls as possible
    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -&gt; nTCPs)
    ntake = min(nTCPs, idTake + 1)
 
    # approach to frame 1
    robot.setPoseFrame(frame1)
    robot.setPoseTool(TCP_0)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.MoveJ(target_app_frame)
 
    # grab ntake balls from frame 1
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted
        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idTake = idTake - 1       
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_On(TCPi, i)
        robot.MoveL(target_app)
  
    # ------------------------------------------------------------------
    # second priority: unload the tool     
    # approach to frame 2 and place the tool balls into table 2
    robot.setPoseTool(TCP_0)
    robot.MoveJ(target_app_frame)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.setPoseFrame(frame2)    
    robot.MoveJ(target_app_frame)
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        if idLeave &gt; nballs_frame2-1:
            raise Exception("No room left to place objects in Table 2")
         
        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted
        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idLeave = idLeave + 1       
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_Off(TCPi, i, frame2)
        robot.MoveL(target_app)
 
    robot.MoveJ(target_app_frame)
 
# Move home when the robot finishes
robot.MoveJ([0,0,0,0,10,-200])
 
 
 
# Gather required items from the station tree
robot = RDK.Item('Fanuc M-710iC/50')
robot_tools = robot.Childs()
#robottool = RDK.Item('MainTool')
frame1 = RDK.Item('Table 1')
frame2 = RDK.Item('Table 2')
 
 
 
# Call custom procedure to remove old objects
cleanup_balls([frame1 , frame2])
 
 
# Make a list of positions to place the objects
frame1_list = pyramid_calc(4)
frame2_list = pyramid_calc(4)
 
# Programmatically place the objects with a custom-made procedure
balls_setup(frame2, frame2_list)
 
# Delete previously generated tools
for tool in robot_tools:
    if tool.Name().startswith('TCP'):
        tool.Delete()
         
# Calculate tool frames for the suction cup tool of 6 suction cups
TCP_list = []
for i in range(nTCPs):
    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)
    TCPi = robot.AddTool(TCPi_pose, 'TCP %i' % (i+1))
    TCP_list.append(TCPi)
 
TCP_0 = TCP_list[0]
 
 
 
# Move balls    
robot.setPoseTool(TCP_list[0])
nballs_frame2 = len(frame2_list)
nballs_frame1 = len(frame1_list)
idTake = nballs_frame2 - 1
idLeave = 0
idTCP = 0
target_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)
 
while idTake &gt;= 0:
    # ------------------------------------------------------------------
    # first priority: grab as many balls as possible
    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -&gt; nTCPs)
    ntake = min(nTCPs, idTake + 1)
 
    # approach to frame 1
    robot.setPoseFrame(frame2)
    robot.setPoseTool(TCP_0)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.MoveJ(target_app_frame)
 
    # grab ntake balls from frame 1
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted
        target = transl(frame2_list[idTake])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idTake = idTake - 1       
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_On(TCPi, i)
        robot.MoveL(target_app)
  
    # ------------------------------------------------------------------
    # second priority: unload the tool     
    # approach to frame 2 and place the tool balls into table 2
    robot.setPoseTool(TCP_0)
    robot.MoveJ(target_app_frame)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.setPoseFrame(frame1)    
    robot.MoveJ(target_app_frame)
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        if idLeave &gt; nballs_frame2-1:
            raise Exception("No room left to place objects in Table 2")
         
        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted
        target = transl(frame1_list[idLeave])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idLeave = idLeave + 1       
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_Off(TCPi, i, frame2)
        robot.MoveL(target_app)
 
    robot.MoveJ(target_app_frame)
 
# Move home when the robot finishes
robot.MoveJ([0,0,0,0,10,-200])</pre>
<h2>w15</h2>
<p>影片翻譯</p>
<p>Inverse kinematics for a 2-joint robot arm using geometry</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/IKOGwoJ2HLk" width="560"></iframe> </p>
<p><span>We saw this simple two-link robot in the previous lecture about forward kinematics</span></p>
<p><span>我們在之前的正向運動學的講座中看到了這個簡單的雙連桿機構</span></p>
<p><span>The tooltip pose of this robot is described simply by two numbers</span></p>
<p><span>這個連趕工具是由兩個數字簡單描述的</span></p>
<p><span>the coordinates x and y with respect to the world coordinate system</span></p>
<p><span>相對於絕對坐標系的x和y</span></p>
<p><span>So, the problem here is that given x and y</span></p>
<p>這裡的問題是我們訂了x和y</p>
<p><span>we want to determine the joined angles, Q1 and Q2</span></p>
<p><span>要如何確定連接角度 Q1和Q2</span></p>
<p><span>The solution that we’re going to follow in this particular section is a geometric one</span></p>
<p><span>在特殊的部分需依照其中一種幾何學的解決方案</span></p>
<p><span>We’re going to start with a simple piece of construction</span></p>
<p><span>我們要從一個簡單的結構上開始</span></p>
<p><span>We’re going to overlay the red triangle on top of our robot</span></p>
<p>假設把一個紅色的三角形放在我們的機構上</p>
<p><span>We know that the end point coordinate is x,y </span>so the vertical height of the triangle is y, the horizontal width is x</p>
<p>以肢端點座標為X和Y 三角形的垂直高度為Y 水平寬度為X</p>
<p><span>And using Pythagoras theorem, we can write r squared equals x squared plus y squared </span><span>So far, so easy</span></p>
<p><span>利用畢氏定理即可得出  r的平方=x的平方+y的平方  目前都很簡單</span></p>
<p>Now, we’re going to look at this triangle highlighted here in red and we want to determine</p>
<p>the angle alpha</p>
<p><span>現在我們來看此處用紅色突出顯示的三角形並且確定出我們想要的角度α</span></p>
<p><span>In order to do that, we need to use the cosine rule</span></p>
<p><span>為了做到這件事我們必須使用餘弦定理</span></p>
<p><span>And if you’re a little rusty on the cosine rule, here is a bit of a refresher</span></p>
<p><span>如果你對餘弦定理有點不熟悉這裡有一些資料可以複習</span></p>
<p><span>We have an arbitrary triangle</span></p>
<p><span></span>這裡有個任意三角形</p>
<p><span>We don’t have to have any right angles in it</span></p>
<p><span>裡面沒有任何直角</span></p>
<p>and we’re going to label the length of this edge as A and the angle opposite that edge, we’re going to label as little a</p>
<p><span>我們把這條邊的長度標為A與這條邊相對的角我們標記為a</span></p>
<p><span>And we do the same for this edge and this</span><span>angle and this edge and this angle</span></p>
<p>對另外<span>兩邊的邊和角做相同的事</span></p>
<p>So all together the sides are labelled capitals A,B and C and the angles are labelled little a, little b and little c</p>
<p><span>把所有的邊都被標記為A,B,C然後角都被標記為a,b,c</span></p>
<p><span>So, the cosine rule is simply this relationship here</span></p>
<p><span>餘弦定理在這裡就可以以這種簡單的關係表示</span></p>
<p><span>It’s a bit like Pythagoras’ theorem except for this extra term on the end with the cos a in it</span></p>
<p><span>它有點類似於畢氏定理只是在最後加了一個帶cosa的項</span></p>
<p><span>Now, let’s apply the cosine rule to the particular triangle we looked at a moment ago</span></p>
<p><span>讓我們把餘弦定理運用在剛才看到的那個特定三角形上</span></p>
<p><span>It’s pretty straightforward to write down this particular relationship</span></p>
<p><span>可以很直接地寫下此種特殊關係</span></p>
<p>We can isolate the term cos alpha which gives us the angle alpha that we’re interested in</p>
<p><span>我們可以將我們所感興趣的α角求出需將給定的cos </span><span class="Y2IQFc" lang="zh-TW">α</span><span>項分離出來</span></p>
<p>And, it’s defined in terms of the constant link lengths, A1 and A2 and the position of the end effector x and y</p>
<p><span>它是以恆定的連桿長度A1及A2以及末端執行器位置x與y來定義的</span></p>
<p>We can write this simple relationship between the angles alpha and Q2</p>
<p><span>我們可以寫出此種於α角和q2之間的簡單關係</span></p>
<p>And we know from the shape of the cosine function that cos of Q2 must be equal to negative of cos alpha</p>
<p><span>而且我們從餘弦函數的形狀得知cos q2須等於 -cos </span><span>α</span></p>
<p>This time, let’s just write an expressionfor the cosine of the joined angle Q2</p>
<p><span>這次，讓我們只寫出有關連接角q2的餘弦表達式</span></p>
<p>Now we’re going to draw yet another red triangle and we’re going apply some simple trigonometry here</p>
<p><span>再畫一個紅色三角形並且在這使用一些簡單的三角函數</span></p>
<p>If we know Q2, then we know this length and this length of the red triangle</p>
<p><span>如果我們知道了q2那我們便可得紅色三角形中q2的對邊長與鄰邊長</span></p>
<p>We can write this relationship for the sine of the joined angle Q2</p>
<p><span>我們可以將這種關係寫為連接角q2的正弦</span></p>
<p>Now we can consider this bigger triangle whose angle is beta and this side length of the triangle is given here in blue</p>
<p><span>我們可以考慮更大的三角形其角度為β這個三角形的邊長用藍色表示</span></p>
<p>And the length of the other side of the triangle is this</p>
<p><span>三角形的另一邊長是這樣表示的</span></p>
<p>so now we can write an expression for the angle beta in terms of these parameters here</p>
<p><span>我們可以用這些參數來寫出一個β角的表達式</span></p>
<p>Going back to the red triangle that we drew earlier we can establish a relationship between Q1 and the angle beta</p>
<p><span>回到之前我們畫的紅色三角形，我們可以在q1和β角之間建立一個關係</span></p>
<p>Introduce yet another angle, this one gamma and we can write a relationship between the angle gamma and the tooltip coordinates x and y</p>
<p><span>代入另一個角度</span><span>γ，我們可寫出γ角和工具軟件座標x和y之間的關係</span></p>
<p>Now we can write a simple relationship between the angles that we’ve constructed gammaand beta and the joined angle we’re interested in which is Q1</p>
<p><span>我們可以用建構出的角度γ,β來寫出γ角和β角與欲求之連接角q1之間的簡單關係</span></p>
<p>And the total relationship looks something like this</p>
<p><span>整體關係看起來像這樣</span></p>
<p>Quite a complex relationship</p>
<p><span>這個是相當複雜的一個關係</span></p>
<p>it gives us the angle of joined one, that’s Q1 in terms of the end effector coordinates y and x and a bunch of constants, a1 and a2 and it’s also a function of the second joint angle Q2</p>
<p><span>此為相當複雜的一個關係它提供了第一關節角q1與端點坐標y和x以及一堆常數a1和a2並且它也是第二關節角q2的函數</span></p>
<p>So, let’s summarize what it is that we have derived here</p>
<p><span>讓我們總結一下在這裡得出的結論為何</span></p>
<p>We have an expression for the cosine of Q2 and we have an expression for Q1</p>
<p><span>我們有一個q2的餘弦表達式，和一個q1表達式</span></p>
<p>Now, the cosine function is symmetrical about 0</p>
<p><span>餘弦函數在0時為對稱的</span></p>
<p>So, if we know the value of the cosine of Q2 then there are two possible solutions a positive angle and a negative angle</p>
<p><span>假如我們得知cosq2，那它便會有正角與負角兩種解</span></p>
<p>We’re going to explicitly choose the positive angle, which means that I can write this expression here</p>
<p><span>在這裡明確的選擇正角，這意味著我可以在此處寫這個表達式</span></p>
<p>And now, we have what we call the inverse kinematic solution for this two-link robot</p>
<p><span>現在我們有了解決雙連桿機構的逆向運動學函式</span></p>
<p>We have an expression for the two joined anglesQ1 and Q2 in terms of the end effector pose x and y and a bunch of constants</p>
<p><span>我們有一個對連接角q1和q2的表達式其與末端執行器構成的x和y和一大堆常數有關</span></p>
<p>You notice that the two equations are not independent</p>
<p><span>你會注意到這兩個方程式並不獨立</span></p>
<p>The equation for Q1 in fact depends on the solution for Q2</p>
<p><span>實際上q1的方程式取決於q2的解</span></p>
<p>In this case, Q2 is negative and we’re going to write the solution for Q2 with a negative sign in front of the inverse cosine</p>
<p><span>在這種情況下q2為負因此我們要在反餘弦前加上負號來寫出q2的解</span></p>
<p>Now, we need to solve for Q1, so we’re going to introduce this particular red triangle the angle beta that we solved previously and the angle gamma which is defined in terms of y and x</p>
<p><span>現在我們要求出q1的解所以我們要引入這個特定的紅色三角形並用之前得出的β角以及用y和x定義出的γ角</span></p>
<p>Now we write a slightly different relationship between Q1 gamma and beta different to what we had before</p>
<p><span>我們在q1γ和β之間寫了一個與之前稍微不同的關係</span></p>
<p>There’s a change of sign involved</p>
<p><span>這涉及到符號的變化</span></p>
<p>Then, we can substitute all that previous equation and come up with this expression for Q1</p>
<p><span>然後將先前所有的方程代入可得出這個q1的表達式</span></p>
<p>Again, there is a change of sign here</p>
<p><span>同樣地這裡也有一個符號的變化</span></p>
<p>Previously this was a negative sign</p>
<p><span>在之前的式子裡這裡是負號</span></p>
<p>And, here in summary form is the solution for the inverse kinematics of our two-link robot when it is in this particular configuration where Q2 is negative</p>
<p><span>在之前的式子裡，這裡是負號值</span></p>
<p>Let’s compare the two solutions, the case where q2 is positive and the case where q2 is negative</p>
<p><span>讓我們在q2為正以及q2為負的情況下進行兩種解法的比較</span></p>
<h3><span>w16</span></h3>
<p>onshape零件圖檔</p>
<p><a href="https://cad.onshape.com/documents/4d8f2e408da5d6493d1ca69d/w/f6075a415b1c4714999d09a6/e/91ef5492cb2494d27f694fc6">https://cad.onshape.com/documents/4d8f2e408da5d6493d1ca69d/w/f6075a415b1c4714999d09a6/e/91ef5492cb2494d27f694fc6</a></p>
<p></p>